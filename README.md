Research Topic
Software Complexity Automation Tool for Industrial Practices with Qualitative and Quantitative Aspects

**Group members**

1.  Akalanka M.H.N : IT19239644
2.  Weerasinghe W.A.H.T : IT19136370
3.  Perera H.K.P.S : IT19131016
4.  Kumari T.N : IT19060804

Main Objective

Implement a tool to automate the software complexity with qualitative and quantitative aspects and to reduce the software complexity

Main Research Question

In the real world, the software is developed to meet unique business or personal objectives, goals. It is not enough to have a final product; 
the software quality and its complexity should be maintained up to the standards. The emphasis of this research is on software complexity. 
Software complexity is defined by the difficulty of performing tasks such as coding, debugging, testing, or modifying the software. 
There are several metrics to measure the software complexity. But those metrics are measured using different aspects and attributes.
Because of that, the outputs of those metrics are inaccurate. There is no metric to consider all the aspects and attributes when measuring the 
software complexity. Also, a major problem in metrics is difficult to measure as a quantitative value because software complexity depends on the person. 
As an exemplification, Cyclomatic Complexity (CC) is one of the most common metrics in software development. This metric also measures only limited 
attributes such as depth and quantity of routines in a piece of code. The above instance proves that the overall software complexity cannot be 
measured by this metric. Therefore, even today it is not possible to measure the software complexity precisely by using the numerous metrics that are 
existing in the real world.

### Akalanka M.H.N -IT19239644

Research Problem
The software development process is going through several interrelated phases of planning, design, and implementation and testing. 
Measuring the complexity of these software phases is an important aspect of the software industry to develop an efficient and robust software applications. 
The software complexity means, according to the IEEE standard is the exact scientific basis for software engineering . The comprehensive understanding 
the software code is directly linked to the degree of software complexity. Also, the hardness of analyzing software is playing an important role in software
development manufacturing . Then, we can define software complexity is the number of computational efforts needed to develop, maintain, and execute 
software code . There are several metrics to measure the software complexity. But those metrics are measured using different aspects and attributes. 
Because of that, the outputs of those metrics are inaccurate. There is no metric to consider all the aspects and attributes when measuring the software 
complexity. Also, a major problem in metrics is difficult to measure as a quantitative value because software complexity depends on the person. As an 
exemplification Cyclomatic Complexity (CC) is one of the most common metrics in software development. This metric also measures only limited attributes 
such as depth and quantity of routines in a piece of code [9]. The above instance proves that the overall software complexity cannot be measured by this 
metric. Therefore, even today it is not possible to measure the software complexity precisely by using the numerous metrics that are existing in the real
world.

Main Objective

*  Rate the user using subjective factors.

Sub Objectives

*  Surveying to select the subjective factors.
*  Users rate themselves based on selected subjective factors.
*  Rate the user through the system by providing a questioner from the system side. 
*  Using the users rating and the system rating train a machine learning model to predict the complexity level as for the future applications



### Kumari T.N - IT19060804

Research Problem
As the knowledge-information society continues, the fields in which digital information is used in various ways are increasing.
As software that uses digital information appears in various fields, such as robots, artificial intelligence, and the Internet of Things,
the scale of software grows and becomes more complex, technology is needed to achieve the sophistication of software quality.
In addition, since software programs require continuous development and patching, a maintenance system that manages the implemented software for high quality is
important for complex software. However, due to invisibility, which is a characteristic of software, it is difficult to measure the complexity of software and to reflect
requirements, making it difficult to maintain software [13]. Software complexity can be reduced by presenting this source code as a visual representation.
People can easily comprehend the visual representation of a source code more than the original source code.
The existing research has done two generate diagrams for the source codes. Those are generating a single existing UML diagram.
Some UML diagrams may not be familiar to users. Therefore, a single UML diagram maybe not be clear to the users.
That is the problem addressed in this research. This research mainly focused to generate a new visual representation that will increase the comprehension
effort and increase the users’ understandability. The survey response proves that the users are more likely to solve problems using the Diagrams (Visual representations).
Another most important question that was asked was where the users like to use a single UML diagram or combination of UML diagram components.
The response indicates that all the users are more likely to use a combination of UML diagram components. The response causes the research problem.

Main Objective

*  Eliminates the user-dependent factors and by that increase the comprehension effort and the user’s understanding by the use of Visual Representation.

Sub Objectives

*  Surveying to get the users information about the UML diagrams and their preference about the Visual representation.
*  Analyze the survey responses and by using that information identifies the most understandable components from the most rated diagrams.
*  Implement a new visual representation as a combined diagram by using the most understandable components of the UML diagrams.
*  Using Abstract Syntax Tree (AST) to get the source code details and generate the appropriate visual representation.



### Perera H.K.P.S - IT19131016

Research Problem 
Many researchers have discussed several types of software complexity metrics, including structural complexity, functional complexity, etc. 
In terms of weyuker’s properties, the proposed measurements are declared as software metrics. Some of the metrics are proposed new ways of measuring the LOC, 
McCabe’s cyclomatic complexity and Hallstead method.  
System complexity is affecting internal and external aspects of the software program. 
A correct metric is leading towards a good software program. 
Since there are several metrics measuring different aspects, gaining an accurate measurement for a software program is required. 
The existing metrics are not considering all the aspects and attributes in the software program. The existing programs are neither cover nor sufficient to cover all aspects.  
Although much work has been done on measuring software complexity, further study is needed to develop software complexity measurement approaches and strategies.

Main Objective

* Standardize a complexity metric using qualitative and quantitative aspects through the software complexity standardized frameworks.

Sub Objective

* Standardize a software complexity metric using qualitative aspects of member one and with quantitative aspects through software complexity metric       evaluation frameworks 
* Those aspects are determined through the attributes of existing metrics and the attributes selected through a survey.


### Weerasinghe W.A.H.T - IT19136370

Research Problem

In the real world, the software is created to achieve certain business or personal purposes. It's not enough to have a final product; the software's quality and complexity must be kept up to par. This study focuses on the complexity of software. The difficulty of doing tasks such as writing, debugging, testing, or altering software is referred to as software complexity.

Writing code, debugging, and maintaining is difficult, yet it's important for excellent software quality. Furthermore, excessive code complexity leads to a higher number of faults, making the code more expensive to maintain. As a result, lowering software complexity may lower the number of faults and defects, as well as the cost of ownership. 

Software complexity can be reduced in a variety of ways, refactoring the source code is one of the methods. However, the majority of developers do not prefer refactoring when coding, as proved by a survey I did. Despite the fact that most developers are unwilling to refactor, the survey that I conducted clearly shows that the majority of developers (92%) prefer to use a tool that automates the refactoring techniques.

Main Objective

*  Automate refactoring techniques and provide appropriate refactoring suggestion methods for a given source code.

Sub Objectives

*  Analyze the given source code
*  Identify the details such as variables, functions, etc in source code
*  Provide the most suitable refactoring techniques as suggestions
*  Apply the suggested refactoring tools the source code
